/*******************************************************************************

Copyright 2010 by tiankong Interactive Game Co., Ltd.
All rights reserved.

This software is the confidential and proprietary information of
tiankong Interactive Game Co., Ltd. ('Confidential Information'). You shall
not disclose such Confidential Information and shall use it only in
accordance with the terms of the license agreement you entered into with
tiankong Interactive  Co., Ltd.

*******************************************************************************/
/**
*	@file		creature.h
*	@author		lc
*	@date		2010/09/08	initial
*	@version	0.0.1.0
*	@brief		ÓÎÏ·ÄÚÉúÎïAIÀà£¬Ò»¸öÓÐÏÞ×´Ì¬»ú£¬°üÀ¨¶àÖÖAI×´Ì¬
*/

#pragma once

#include "ai_transition.h"
#include "ai_trigger.h"
#include "script_mgr.h"
#include "creature.h"
#include "creature_order.h"
#include "pet_tracker.h"

class Unit;
class Creature;
class AIState;
class AITransition;
class AITriggerMgr;
class CVector2D;
struct tagCreatureAI;
struct tagTriggerProto;
enum  EFLEETIME;

const FLOAT CREATURE_RETURN_HEIGH = 100.0;

//-----------------------------------------------------------------------------
// AI×´Ì¬ÀàÐÍ
//-----------------------------------------------------------------------------
enum AIStateType
{
	AIST_Idle			= 0,			// ¿ÕÏÐ×´Ì¬
	AIST_Pursue			= 1,			// ×·»÷×´Ì¬
	AIST_Attack			= 2,			// ¹¥»÷×´Ì¬
	AIST_Flee			= 3,			// ÌÓÅÜ×´Ì¬
	AIST_SOS			= 4,			// ºô¾È×´Ì¬
	AIST_Return			= 5,			// ·µ»Ø×´Ì¬
	AIST_Follow			= 6,			// ¸úËæ×´Ì¬
	AIST_SpaceOut		= 7,			// À­¿ª¾àÀë
	//AIST_								// Õ½±¸¿ÕÏÐ×´Ì¬
	AIST_PetIdle		= 8,			// ³èÎïË÷µÐ×´Ì¬
	AIST_PetAttack		= 9,			// ³èÎïÕ½¶·×´Ì¬
	AIST_Pet_Pursue		= 10,			// ³èÎï×·»÷×´Ì¬
	AIST_Alert			= 11,			// ¾¯½ä×´Ì¬
	AISI_Script			= 12,			// ½Å±¾×´Ì¬
	AIST_Talk			= 13,			// ¶Ô»°×´Ì¬
};

//-----------------------------------------------------------------------------
// AI×´Ì¬³éÏóÀà
//-----------------------------------------------------------------------------
class AIState
{
public:
	virtual ~AIState() {}

	// ½øÈë×´Ì¬´¥·¢
	virtual VOID OnEnter(AIController* pAI) = 0;
	// Àë¿ª×´Ì¬´¥·¢
	virtual VOID OnExit(AIController* pAI) = 0;
	// ¸üÐÂº¯Êý
	virtual VOID Update(AIController* pAI) = 0;
	// ÊÂ¼þÏìÓ¦
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1=0, DWORD dwEventMisc2=0) = 0;
};

//-----------------------------------------------------------------------------
// ¿ÕÏÐ×´Ì¬
//-----------------------------------------------------------------------------
class AIStateIdle : public AIState
{
public:
	virtual ~AIStateIdle() {}

public:
	AIStateIdle() {}
	static AIStateIdle* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);	// ²ÎÊý»á²»»áÌ«ÉÙÁË

private:
	AIStateIdle(const AIStateIdle&);
	AIStateIdle& operator=(const AIStateIdle&);
};

//-----------------------------------------------------------------------------
// ×·»÷×´Ì¬
//-----------------------------------------------------------------------------
class AIStatePursue: public AIState
{
public:
	AIStatePursue() {}
	virtual ~AIStatePursue() {}

public:
	static AIStatePursue* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStatePursue(const AIStatePursue&);
	AIStatePursue& operator=(const AIStatePursue&);
};

//-----------------------------------------------------------------------------
// ¹¥»÷×´Ì¬
//-----------------------------------------------------------------------------
class AIStateAttack: public AIState
{
public:
	AIStateAttack() {}
	virtual ~AIStateAttack() {}

public:
	static AIStateAttack* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStateAttack(const AIStateAttack&);
	AIStateAttack& operator=(const AIStateAttack&);
};

//-----------------------------------------------------------------------------
// ÌÓÅÜ×´Ì¬
//-----------------------------------------------------------------------------
class AIStateFlee: public AIState
{
public:
	AIStateFlee() {}
	virtual ~AIStateFlee() {}

public:
	static AIStateFlee* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStateFlee(const AIStateFlee&);
	AIStateFlee& operator=(const AIStateFlee&);
};

//-----------------------------------------------------------------------------
// ºô¾È×´Ì¬
//-----------------------------------------------------------------------------
class AIStateCallHelp : public AIState
{
public:
	AIStateCallHelp() {}
	virtual ~AIStateCallHelp() {}

public:
	static AIStateCallHelp* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStateCallHelp(const AIStateCallHelp&);
	AIStateCallHelp& operator=(const AIStateCallHelp&);
};

//-----------------------------------------------------------------------------
// ·µ»Ø×´Ì¬
//-----------------------------------------------------------------------------
class AIStateReturn : public AIState
{
public:
	AIStateReturn() {}
	virtual ~AIStateReturn() {}

public:
	static AIStateReturn* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStateReturn(const AIStateReturn&);
	AIStateReturn& operator=(const AIStateReturn&);
};

//-----------------------------------------------------------------------------
// À­¿ª¾àÀë
//-----------------------------------------------------------------------------
class AIStateSpaceOut : public AIState
{
public:
	AIStateSpaceOut() {}
	virtual ~AIStateSpaceOut() {}

public:
	static AIStateSpaceOut* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc/* =0 */, DWORD dwEventMisc2/* = 0 */);

private:
	AIStateSpaceOut(const AIStateSpaceOut&);
	AIStateSpaceOut& operator=(const AIStateSpaceOut&);
};

//-----------------------------------------------------------------------------
// ¸úËæ×´Ì¬£¬Ò»°ã×÷ÎªÈ«¾Ö×´Ì¬
//-----------------------------------------------------------------------------
class AIStateFollow: public AIState
{
public:
	AIStateFollow() {}
	virtual ~AIStateFollow() {}

public:
	static AIStateFollow* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStateFollow(const AIStateFollow&);
	AIStateFollow& operator=(const AIStateFollow&);
};

//-----------------------------------------------------------------------------
// ½Å±¾×´Ì¬£¬ÓÃ×÷ËùÓÐ½Å±¾
//-----------------------------------------------------------------------------
class AIStateScript: public AIState
{
public:
	AIStateScript() {}
	virtual ~AIStateScript() {}

public:
	static AIStateScript* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStateScript(const AIStateScript&);
	AIStateScript& operator=(const AIStateScript&);
};

//-----------------------------------------------------------------------------
// ¶Ô»°×´Ì¬
//-----------------------------------------------------------------------------
class AIStateTalk: public AIState
{
public:
	AIStateTalk() {}
	virtual ~AIStateTalk() {}

public:
	static AIStateTalk* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStateTalk(const AIStateTalk&);
	AIStateTalk& operator=(const AIStateTalk&);
};



//-----------------------------------------------------------------------------
// ³èÎïË÷µÐ×´Ì¬
// 
//-----------------------------------------------------------------------------
class AIStatePetIdle : public AIState
{
public:
	AIStatePetIdle() {}
	virtual ~AIStatePetIdle() {}

public:
	static AIStatePetIdle* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStatePetIdle(const AIStatePetIdle&);
	AIStatePetIdle& operator=(const AIStatePetIdle&);
};

//-----------------------------------------------------------------------------
// ³èÎïÕ½¶·×´Ì¬
// 
//-----------------------------------------------------------------------------
class AIStatePetAttack: public AIState
{
public:
	AIStatePetAttack() {}
	virtual ~AIStatePetAttack() {}

public:
	static AIStatePetAttack* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStatePetAttack(const AIStatePetAttack&);
	AIStatePetAttack& operator=(const AIStatePetAttack&);
};


//-----------------------------------------------------------------------------
// ³èÎïµÄ×·µÐ×´Ì¬
// 
//-----------------------------------------------------------------------------
class AIStatePetPursue : public AIState
{

public:
	AIStatePetPursue() {}
	virtual ~AIStatePetPursue() {}

public:
	static AIStatePetPursue* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:
	AIStatePetPursue(const AIStatePetPursue&);
	AIStatePetPursue& operator=(const AIStatePetPursue&);

};


//-----------------------------------------------------------------------------
// ¹ÖÎï¾¯½ä×´Ì¬
// 
//-----------------------------------------------------------------------------
class AIStateAlert : public AIState
{

public:
	AIStateAlert() {}
	virtual ~AIStateAlert() {}

public:

	static AIStateAlert* Instance();

	virtual VOID OnEnter(AIController* pAI);
	virtual VOID OnExit(AIController* pAI);
	virtual VOID Update(AIController* pAI);
	virtual BOOL OnEvent(AIController* pAI, Unit* pSrc, INT nEventType, DWORD dwEventMisc1/* =0 */, DWORD dwEventMisc2/* =0 */);

private:

	AIStateAlert( const AIStateAlert& );
	AIStateAlert& operator=( const AIStateAlert& );

};


//-----------------------------------------------------------------------------
// AI¿ØÖÆÆ÷£¬ÎªÒ»ÓÐÏÞ×´Ì¬»ú
//-----------------------------------------------------------------------------
class AIController
{
public:
	
	explicit AIController(Creature* pCreature, const tag_map_way_point_info_list* patrolList);
	~AIController() { Destroy(); }

	//--------------------------------------------------------------------------
	// ³õÊ¼»¯ºÍ¸üÐÂ
	//--------------------------------------------------------------------------
	VOID			InitPatrol(const tag_map_way_point_info_list* patrolList);
	VOID			InitAIProto();
	VOID			InitTriggerMgr();
	VOID			InitAITransition();
	VOID			InitPathFinder();

	VOID			Update();
	VOID			Destroy();
	VOID			Refresh();

	//--------------------------------------------------------------------------
	// ÊÂ¼þ´¥·¢
	//--------------------------------------------------------------------------
	VOID			OnEvent(Unit* pSrc, INT nEventType, DWORD dwEventMisc1=0, DWORD dwEventMisc2=0);

	//--------------------------------------------------------------------------
	// µÃµ½Ö÷ÈË
	//--------------------------------------------------------------------------
	Creature*		GetOwner()								{ return m_pOwner; }

	//--------------------------------------------------------------------------
	// ×´Ì¬Ïà¹Ø
	//--------------------------------------------------------------------------
	AIStateType		GetCurrentStateType()					{ return m_eCurAIState; }
	AIState*		GetCurrentState()						{ return m_pCurrentState; }
	AIState*		GetPreviousState()						{ return m_pPreState; }
	AIState*		GetGlobalState()						{ return m_pGlobalState; }

	VOID			SetCurrentStateType(AIStateType eType)	{ m_eCurAIState = eType; }
	VOID			SetCurrentState(AIState* pState)		{ m_pCurrentState = pState; }
	VOID			SetPreviousState(AIState* pState)		{ m_pPreState = pState; }
	VOID			SetGlobalState(AIState* pState)			{ m_pGlobalState = pState; }

	VOID			ChangeState(AIStateType eState);

	//---------------------------------------------------------------------------
	// Õ½¶·Âß¼­Ïà¹Ø
	//---------------------------------------------------------------------------

	// Í¨ÓÃ
	DWORD			GetEnterCombatTick() const			{ return m_dwEnterCombatTick; }
	const Vector3&	GetEnterCombatPos() const			{ return m_vPosEnterCombat; }
	VOID			SetEnterCombatPos(Vector3& vPos)	{ m_vPosEnterCombat = vPos; }
	VOID			SetEnterCombatTick(DWORD dwTick)	{ m_dwEnterCombatTick = dwTick; }
	BOOL			IsTargetValid(DWORD dwID);
	DWORD			GetTargetIDByType(ECreatureTargetFriendEnemy eTargetType);

	// Ñ²Âß
	BOOL			IsReversePatrol() const				{ return m_bReversePatrol; }
	BOOL			IsPatroling() const					{ return m_bIsPatroling; }
	VOID			SetIsPatroling(BOOL bPatrol)		{ m_bIsPatroling = bPatrol; }
	VOID			SetIsReversePatrol(BOOL bReverse)	{ m_bReversePatrol = bReverse; }
	VOID			ReSetPatrolRestTick()				{ m_nPatrolRestTick = get_tool()->tool_rand() % CREATURE_PATROL_REST_TICK_INTERVAL + CREATURE_PATROL_REST_TICK_MIN; }
	VOID			ReSetPatrolRestTick( DWORD dw_time ) { m_nPatrolRestTick = dw_time; }
	VOID			UpdatePatrol();
	VOID			StartPatrol();
	VOID			PausePatrol(const Vector3& vFace, DWORD dw_time);
	BOOL			MoveWayPoint(INT nIndex, EMoveState nMoveType);
	// Ë÷µÐ
	VOID			ReSetLookForTargetTick()			{ m_nLookForTargetTick = get_tool()->tool_rand() % CREATURE_LOOK_FOR_ENEMY_REST_TICK_INTERVAL + CREATURE_LOOK_FOR_ENEMY_REST_TICK_MIN; }
	DWORD			UpdateLookForEnemy();
	DWORD			StartLookForEnemy();
	BOOL			UpdateLockTarget();

	// ³èÎïË÷µÐ
	DWORD			UpdateLookForEnemyPet();
	DWORD			StartLookForEnemyPet();

	// ¹ÖÎï¾¯½ä×´Ì¬
	DWORD			UpdateLookForEnemyAlert();
	DWORD			StartLookForEnemyAlert();

	// ¹ÖÎïÇóÖú
	VOID			ResetCallHelpTime()					{ m_dwCallHelpTime = CREATURE_CALLHELP_TICK; }
	VOID			UpdateCallHelp();
	VOID			CallHelp();

	// »¤³ÇNPCµÄË÷µÐÂß¼­
	void			StartLookForEnemyHuCheng();

	// ×·»÷
	const Vector3&	GetPursueTargetPos() const			{ return m_vPursueTargetPos; }
	DWORD			GetTargetUnitID() const				{ return m_dwTargeUnitID; }
	Unit*			GetPursueTarget();
	BOOL			GetPosNearPursueTarget(Unit* pTarget, Vector3& vPos);
	VOID			StartPursue(Unit* pTarget, BOOL bfanwei = true);
	VOID			UpdatePursue(Unit* pTarget);
	VOID			SetPursueTargetPos(Vector3& vPos)	{ m_vPursueTargetPos = vPos; }
	VOID			SetTargetUnitID(DWORD dwID)			{ m_dwTargeUnitID = dwID; m_pOwner->SetTargetID(dwID);}
	VOID			ReSetLockTargetTime()				{ m_nLockTargetTick = get_tool()->tool_rand() % CREATURE_LOCK_TARGET_TICK_INTERVAL + CREATURE_LOCK_TARGET_MIN_TICK; }

	// ³èÎï×·»÷
	VOID			StartPursuePet(Unit* pTarget);
	VOID			UpdatePursuePet(Unit* pTarget);

	// ¹¥»÷
	BOOL			IsInAttackDist(DWORD dwTargetUnitID);
	BOOL			IsInAlertDist( DWORD dwTargetID );
	BOOL			IsInspiration( DWORD dwTargetUnitID );
	INT				GetNextAttackWaitTick()	const		{ return m_nNextAttackWaitTick; }
	VOID			SetNextAttackWaitTick(INT nTick)	{ m_nNextAttackWaitTick = nTick; }
	VOID			CountDownNextAttackWaitTick()		{ --m_nNextAttackWaitTick; }
	INT				GetCheckAIEvnetTick() const			{ return m_nCheckAIEventTick; }
	VOID			SetCheckAIEventTick(INT nTick)		{ m_nCheckAIEventTick = nTick; }
	INT				AIUseSkill(DWORD dwSkillID, DWORD dwTargetUnitID);
	DWORD			GetAIUseSkillID()					{ return m_dwUseSkillID; }

	// ÌÓÅÜ
	const Vector3&	GetFleePos() const					{ return m_vFleePos; }
	VOID			SetFleePos(Vector3 vPos)			{ m_vFleePos = vPos; }
	BOOL			IsArrivedFleePos()					{ return m_bArrivedFleePos; }
	VOID			SetIsArrivedFleePos(BOOL bArrived)	{ m_bArrivedFleePos = bArrived; }
	VOID			SetFleeTime(EFLEETIME eFleeTime)	{ m_eFleeTime = eFleeTime; }
	EFLEETIME		GetFleeTime()						{ return m_eFleeTime; }
	VOID			CountDownNextFleeTick()				{ --m_dwFleeTick; }
	DWORD			GetFleeTick()						{ return m_dwFleeTick; }
	VOID			SetFleeTick(DWORD dwFleeTick)		{ m_dwFleeTick = dwFleeTick; }                                                                     
	VOID			CalFleePos();
	VOID			StartFlee(Vector3 vFleePos);
	VOID			UpdateFlee();

	// ºô¾È
	BOOL			CalHelpPos();
	DWORD			GetHelperID()						{ return m_dwHelperID; }
	VOID			SetHelperID(DWORD dwHelperID)		{ m_dwHelperID = dwHelperID; }
	package_list<DWORD>&	GetHelpList()						{ return m_listHelpID; }
	BOOL			NeedReCalHelpPos();

	// ±£³Ö¾àÀë
	BOOL			CalSpaceOutPos();
	VOID			StartSpaceOut();
	VOID			UpdateSpaceOut();
	DWORD			GetSpaceOutTick()					{ return m_dwSpaceOutTick; }
	BOOL			IsArrivedPos()						{ return m_bArrivedPos; }
	VOID			SetIfArrivedPos(BOOL bArrived)		{ m_bArrivedPos = bArrived; }

	// ·µ»Ø
	VOID			StartReturn();
	VOID			UpdateReturn();
	BOOL			IsArrivedReturnPos()				{ return m_bArrivedReturnPos; }

	//---------------------------------------------------------------------------
	// AI×ª»»Æ÷Ïà¹Ø
	//---------------------------------------------------------------------------
	AITransition*	GetTransition()						{ return m_pTransition; }

	//----------------------------------------------------------------------------
	// ´¥·¢Æ÷¹ÜÀíÆ÷Ïà¹Ø
	//----------------------------------------------------------------------------
	AITriggerMgr*	GetAITriggerMgr()					{ return m_pAITrigger; }

	//----------------------------------------------------------------------------
	// ³ðºÞÏà¹Ø
	//----------------------------------------------------------------------------
	DWORD			RandRoleInEnmityList();
	DWORD			GetMinEnmityInEnmityList();
	DWORD			RandRoleInEnemityListNotFirst();
	VOID			AddEnmity(Unit *pUnit, INT nValue, BOOL bSyncTeam=TRUE);
	VOID			AddEnmityMod(Unit *pUnit, INT nValue, BOOL bSyncTeam=TRUE);
	VOID			ClearAllEnmity();
	VOID			ClearEnmity(DWORD dw_role_id);
	VOID			GetEnmityList(std::vector<tagEnmity*>& vecEnmityList);
	VOID			SetEnmityActive(DWORD dw_role_id, BOOL bActive);
	BOOL			IsEnmityListEmpty();
	VOID			CalMaxEnmity();
	DWORD			GetCurrentVictim()				{ return m_dwCurrentVictim; }
	INT				GetEnmityValue(DWORD dwID);
	INT				GetBaseEnmityValue(DWORD dwID);
	VOID			ClearEnmityModValue(DWORD dwID);
	VOID			SetCurrentVictim(DWORD dwID)	{ m_dwCurrentVictim = dwID; }
	BOOL			IsEnmityListAllInvincible();

	//----------------------------------------------------------------------------
	// ½Å±¾Ïà¹Ø
	//----------------------------------------------------------------------------
	VOID			SetScriptUpdateTimer(INT nTimer)	{ m_nScriptUpdateTimer = nTimer; }

	//----------------------------------------------------------------------------
	// ¶Ô»°Ïà¹Ø
	//----------------------------------------------------------------------------
	VOID SetTalkTime(DWORD dw_time) { m_dwTalkTime = dw_time; }

	DWORD& GetTalkTime() { return m_dwTalkTime; }
	
	//----------------------------------------------------------------------------
	// »ñµÃ¸ú×ÙÆ÷
	//----------------------------------------------------------------------------
	PetTracker*		GetTracker() { return m_pTracker; }
	
	const tagCreatureAI*	GetAIProto() { return m_pAIProto; }

protected:
	//----------------------------------------------------------------------------
	// ¸üÐÂÏà¹Ø
	//----------------------------------------------------------------------------
	VOID			UpdateAIController();
	VOID			UpdateTransition();
	VOID			UpdateCurrentState();
	VOID			UpdateTriggerMgr();

	//----------------------------------------------------------------------------
	// ×´Ì¬Ïà¹Ø
	//----------------------------------------------------------------------------
	AIState*		GetStateByType(AIStateType eStateType);

	//----------------------------------------------------------------------------
	// ×´Ì¬×ª»»Æ÷Ïà¹Ø
	//----------------------------------------------------------------------------
	AITransition*	GetTransitionByType();

	//----------------------------------------------------------------------------
	// ¸¨Öúº¯Êý
	//----------------------------------------------------------------------------
	BOOL			IsInStateCantUpdateAI();
	
protected:
	Creature*				m_pOwner;					// ¶ÔÓ¦µÄÉúÎï

	//----------------------------------------------------------------------------
	// ×´Ì¬
	//----------------------------------------------------------------------------
	AIStateType				m_eCurAIState;				// µ±Ç°AI×´Ì¬Ã¶¾Ù
	AIState*				m_pCurrentState;			// µ±Ç°AI×´Ì¬
	AIState*				m_pPreState;				// ÉÏÒ»´ÎµÄ×´Ì¬
	AIState*				m_pGlobalState;				// È«¾ÖAI×´Ì¬

	//----------------------------------------------------------------------------
	// ×´Ì¬×ª»»Æ÷
	//----------------------------------------------------------------------------
	AITransition*			m_pTransition;				// AI×´Ì¬×ª»»Æ÷

	//----------------------------------------------------------------------------
	// ´¥·¢Æ÷¹ÜÀíÆ÷
	//----------------------------------------------------------------------------
	AITriggerMgr*			m_pAITrigger;				// AI´¥·¢Æ÷¹ÜÀíÀà

	//----------------------------------------------------------------------------
	// ÊôÐÔ
	//----------------------------------------------------------------------------
	const tagCreatureProto*	m_pProto;					// ¸ÃÉúÎï¶ÔÓ¦µÄ¾²Ì¬ÊôÐÔ
	const tagCreatureAI*	m_pAIProto;					// ¸ÃÉúÎï¶ÔÓ¦µÄAI¾²Ì¬ÊôÐÔ

	//----------------------------------------------------------------------------
	// ½Å±¾
	//----------------------------------------------------------------------------
	const CreatureScript*	m_pScript;					// ¹ÖÎï½Å±¾
	INT						m_nScriptUpdateTimer;		// ¹ÖÎï½Å±¾¸üÐÂAIµÄÊ±¼ä£¬³õÊ¼»¯Ê±ÎªINVALID_VALUE£¬²»¸üÐÂ£¬ÓÉ½Å±¾À´ÉèÖÃÕâ¸öÊ±¼ä
	INT						m_nScriptUpdateCountDown;	// ¹ÖÎï½Å±¾¸üÐÂAIµ¹¼ÆÊ±

	//-----------------------------------------------------------------------------
	// AIÕ½¶·Âß¼­ÊôÐÔ
	//-----------------------------------------------------------------------------

	// ¿ÕÏÐ×´Ì¬
	Vector3*				m_pWPArray;					// Â·¾¶Ñ²Âß¹ÖµÄÑ²Âßµ¼º½µãÁÐ±í
	DWORD*					m_pWayPointTime;			// µ¼º½µãÉÏÍ£ÁôµÄÊ±¼ä
	INT						m_nWPNum;					// ¹²ÓÐ¼¸¸öµ¼º½µã
	INT						m_nWPIndex;					// µ±Ç°Ñ²ÂßÔÚÄÄ¸öµ¼º½µã
	BOOL					m_bReversePatrol;			// Â·¾¶Ñ²Âß¹ÖÊÇ·ñÕýÔÚÑØ×ÅÏà·´Â·¾¶Ñ²Âß
	BOOL					m_bIsPatroling;				// ÕýÔÚÑ²Âß
	DWORD					m_nPatrolRestTick;			// ½øÐÐÏÂÒ»¸öÂ·¾¶µãÐÝÏ¢µÄTick
	INT						m_nLookForTargetTick;		// ÉÏÒ»´ÎË÷µÐµÄTick


	// ×·»÷ºÍ¹¥»÷
	Vector3					m_vPursueTargetPos;			// ¹ÖÎï×·»÷µ±Ç°µÄÄ¿±êµã
	BOOL					m_bPursueFailed;			// ×·»÷Ê§°Ü
	BOOL					m_bCanNotPursue;			// ÔÝÊ±²»ÄÜ×·»÷
	BOOL					m_bPathFinding;				// Ñ°Â·ÖÐ
	INT						m_nCheckPursueTick;			// ¼ä¸ô²éÑ¯ÒÆ¶¯µÄÊ±¼ä¼ä¸ô

	DWORD					m_dwTargeUnitID;			// Ä¿±ê¶ÔÏóID
	INT						m_nCheckAIEventTick;		// ÉÏÒ»´Î¼ì²âAIÊÂ¼þµÄtick
	DWORD					m_dwEnterCombatTick;		// ½øÈëÕ½¶·µÄtick

	DWORD					m_dwUseSkillID;				// Ê¹ÓÃµÄ¼¼ÄÜID
	INT						m_nNextAttackWaitTick;		// ±¾´Î¹¥»÷Íê³Éºó£¬ÏÂ´Î¹¥»÷ÐèÒªµÈ´ýµÄÊ±¼ä
	DWORD					m_dwSerial;					// ¹¥»÷ÐòÁÐºÅ

	// ÌÓÅÜ
	Vector3					m_vFleePos;					// ÌÓÅÜµÄÄ¿±êµã
	CVector2D				m_vFleeDir;					// ÌÓÅÜµÄ·½Ïò
	DWORD					m_dwFleeTick;				// ÌÓÅÜ×´Ì¬³ÖÐøÊ±¼ä
	BOOL					m_bArrivedFleePos;			// ÊÇ·ñµ½´ïÌÓÅÜµÄÄ¿±êµã
	EFLEETIME				m_eFleeTime;				// ¼ÆÈëÌÓÅÜ×´Ì¬µÄ´ÎÊý
	DWORD					m_dwHelperID;				// Çó¾È¶ÔÏóID
	package_list<DWORD>			m_listHelpID;				// Çó¾È¶ÔÏóÁÐ±í

	// ·µ»Ø
	Vector3					m_vPosEnterCombat;			// ½øÈëÕ½¶·Ê±µÄ×ø±ê
	BOOL					m_bArrivedReturnPos;		// ÊÇ·ñ·µ»Øµ½½øÈëÕ½¶·Ê±µÄ×ø±ê

	// ±£³Ö¾àÀë
	DWORD					m_dwSpaceOutTick;			// ±£³Ö¾àÀë´¥·¢¼ä¸ô
	BOOL					m_bArrivedPos;				// ÊÇ·ñµ½´ïÄ¿±êµã

	//-----------------------------------------------------------------------
	// ³ðºÞÏµÍ³
	//-----------------------------------------------------------------------
	package_map<DWORD, tagEnmity*>	m_mapEnmity;		// ³ðºÞÁÐ±í
	DWORD					m_dwMaxEnmityUnitID;		// ×î´ó³ðºÞID
	DWORD					m_dwCurrentVictim;			// µ±Ç°¹¥»÷Ä¿±ê
	INT						m_nLockTargetTick;			// Ëø¶¨Ä¿±êµ¹¼ÆÊ±
	INT						m_nNoAnmityTick;			// Ã»ÓÐÔö¼Ó³ðºÞµÄÐÄÌøÊý
	INT						m_nNoAttackTick;			// Ã»ÓÐ¹¥»÷µÄÐÄÌøÊý

	//-----------------------------------------------------------------------
	// Ñ°Â·Ïà¹Ø
	//-----------------------------------------------------------------------
	PathFinder*				m_pPathFinder;
	
	//-----------------------------------------------------------------------
	// ¸úËæ½ÇÉ«Ïà¹Ø
	//-----------------------------------------------------------------------
	PetTracker*				m_pTracker;	

public:
	//-----------------------------------------------------------------------
	// ¹ÖÎïµÄ×·»÷ÐÐÎª
	//-----------------------------------------------------------------------
	ECreaturePursueType		m_ePursueType;
	// ÔÚÒ»¶¨Ìõ¼þÏÂ´¥·¢£¬ÔÚÍÆ³ö·µ»Ø×´Ì¬ÊÇÖØÖÃÎªFALSE,½øÈë×·»÷×´Ì¬ÏÂÖÃÎªTRUE
	// À´¿ØÖÆ¹ÖÎï²»ÄÜ¶à´Îºô¾È
	BOOL					m_bCalHelp;					// ÊÇ·ñÖ÷¶¯ºô¾È
	DWORD					m_dwCallHelpTime;			// ¹ÖÎïÖ÷¶¯ÇóÖúµÄÊ±¼äÏÞÖÆ

	DWORD					m_dwTalkTime;				// ¶Ô»°Ê±¼ä

	DWORD					dw_help_time;				// ºô¾ÈorÌÓÅÜ³ö·¢Ê±¼ä

};











